<!DOCTYPE html>
<html>

<head>
	<meta charset=utf-8>
	<title>Img3D</title>
	<style>
		body {
			margin: 0;
		}

		img {
			display: none;
		}
	</style>
</head>

<body>
	<canvas id="renderer"></canvas>
	<canvas id="raw-image" width="600" height="375"></canvas>

	<script src="js/three.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
	<script src="js/OrbitControls.js"></script>

	<script>
		var renderer, scene, camera, pointCloud, context, material, geometry, WIDTH, HEIGHT, originalColor, originalPosition, newPosition, newColor, toColorspace, toColorspaceKanoised, toImageKanoised, alpha;

		// Load image, then inititalize when it is done loading
		var loader = new THREE.ImageLoader();
		var myImageData, pointsGeometry;
		loader.load(
			'img/xp-mini.jpg',
			function (image) {
				var canvas = document.getElementById('raw-image');
				context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, 100, 63);

				init();
				render();
			}
		);

		var vector3Array = function (amount) {
			vector3s = [];
			for (var i = 0; i < amount; ++i) {
				vector3s.push(new THREE.Vector3());
			}
			return vector3s;
		}

		var copyVector3Array = function (from) {
			var to = vector3Array(from.length);
			console.log(from);
			for (var i = 0; i < from.length; ++i) {
				to[i].x = from[i].x;
				to[i].y = from[i].y;
				to[i].z = from[i].z;
			}
			return to;
		}

		var copyColorsAndPositions = function () {
			var colors = geometry.colors;
			var vertices = geometry.vertices;
			originalColor = copyVector3Array(colors);
			originalVertices = copyVector3Array(vertices);
		}

		var animatePoints = function (points, from, to, alpha) {
			for (var i = 0; i < points.length; ++i) {
				points[i].lerpVectors(from, to, alpha);
			}
		}

		var startToColorspaceAnimation = function () {
			newPosition = copyVector3Array(originalColor);
			toColorspace = true;
		}

		var startToColorspaceKanoisedAnimation = function () {
			newColor = copyVector3Array(originalColor);// brandon's thing
			toColorspaceKanoised = true;

		}
		var startToImageKanoisedAnimation = function () {
			newPosition = copyVector3Array(originalPosition);
			toImageKanoised = true;

		}

		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			renderer = new THREE.WebGLRenderer({
				canvas: document.getElementById("renderer")
			});
			renderer.setSize(window.innerWidth, window.innerHeight);

			camera.position.z = 80;

			var windowResize = THREEx.WindowResize(renderer, camera)
			controls = new THREE.OrbitControls(camera, renderer.domElement);

			// point cloud geometry
			geometry = new THREE.Geometry();

			WIDTH = 100;
			HEIGHT = 63;

			var image = context.getImageData(0, 0, WIDTH, HEIGHT);

			for (var x = 0; x < WIDTH; x++) {
				for (var y = 0; y < HEIGHT; y++) {
					var startPixel = (x * 4) + (y * 4 * WIDTH);
					geometry.vertices.push(new THREE.Vector3(-x + WIDTH / 2, -y + HEIGHT / 2, 0));
					geometry.colors.push(new THREE.Color(image.data[startPixel] / 255, image.data[startPixel + 1] / 255, image.data[startPixel + 2] / 255));
				}
			}

			// material
			material = new THREE.PointsMaterial({
				size: 1.5,
				transparent: true,
				opacity: 0.7,
				vertexColors: THREE.VertexColors
			});

			// point cloud
			pointCloud = new THREE.Points(geometry, material);

			scene.add(pointCloud);

			copyColorsAndPositions()
			alpha = 0;
		}

		function render() {
			requestAnimationFrame(render);

			if (toColorspace) {
				alpha += 1/120;
				animatePoints(geometry.vertices, originalPosition, newPosition, alpha);
			} else if (toColorspaceKanoised) {
				alpha += 1/120;
				animatePoints(geometry.vertices, originalColor, newPosition, alpha);
				animatePoints(geometry.colors, originalColor, newColor, alpha);
			} else if (toImageKanoised) {
				alpha += 1/120;
				animatePoints(geometry.vertices, originalPosition, newPosition, alpha);
			}

			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
